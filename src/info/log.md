## 前言

本项目始于 2021 年夏，基于[星空列车与白的旅行](cusky.tk/webgal/hoshizora/)项目

迄今为止，星夜已经经历了数次 UI 逻辑和核心逻辑的重构，由于工作量和时间的不平衡，此项目的目标或许在很长一段时间内都无法达到，在此，编写一个日志，记录我这些时间以来对视觉小说引擎开发的经历和经验

## 缩放

在从头开发一款视觉小说游戏时，遇到的第一件事就是如何适配不同的屏幕大小，事实上，视觉小说的布局是**绝对**的（就像其他任何的游戏一样？），它们不需要随着屏幕大小的变化来改变彼此之间的大小和距离比例，然而，在 Web 平台上实现这一点却需要废一番功夫

一开始，我采用了 Web 开发中常用的 UI 自适应方案（尽管这其实并不适合于视觉小说的开发，但是我当时并不能意识到这一点），使用%来确定相对单位，然而这在略复杂的定位和布局嵌套中就会造成巨大的工作量和极差的可读性，有些情况下更是连直接使用%都做不到，而需要各种魔法来实现保持比例，并且这种方案下仍旧会造成 UI 的偏移，还有浏览器限制字体大小最小为 12px 的问题。为了实现`星空列车与白的旅行`的 UI 布局，我按了一周计算器来把绝对数值转换为相对比例，当时我就在设想一个使用绝对坐标和自动缩放来实现屏幕自适应的方式了

在新的重构阶段，我发现了`scale`这个 css 属性，它可以对下层元素进行缩放，完美的符合了我的需求。通过参考和摸索，我实现了通过屏幕尺寸来计算 scale 属性的数值，并把这个自适应功能的实现进行了封装，这样，UI 的编写者只需要通过一个固定的画布大小来编写 UI，并书写同样使用固定的**px**单位的 css，而无需关心 UI 自适应的问题

视觉小说的布局有两种可能的方式，`铺满屏幕`和`保持比例`：采用铺满屏幕的方式会使画面变形来填满屏幕，而保持画布比例的方式则会在屏幕的上下或左右留下空白边缘。星夜同时支持这两者，留给用户自由选择

## 暂停

解决了开发视觉小说 UI 出现的问题，接下来就要进行游戏逻辑的开发了，而首先让我头疼的就是游戏要如何暂停，这在其他语言中是一个感觉比较好解决的问题，只需使用 sleep 就可以停止线程的运行，但是在 js 中却是一个麻烦的问题，因为 js 只有单线程，并且不能 sleep

我在网上查询了一些资料，使用 while(true)实现的 sleep 简直异想天开，最终卡死了我的浏览器，在无计可施的时候我甚至尝试将函数 toString 再切分来实现我的目的，最终在一番折腾之后，我了解到了封装 Promise 的思路，并且实现了 await sleep(time) ，这同时部分解决了`快进`的问题，时间控制的实现是引擎的核心，而 Promise 则为接下来的实现打开了一扇窗口

## 幕与命令

开发视觉小说游戏逻辑要遇到的另一个问题就是剧本结构的设计，得益于对`星空列车与白的旅行`原作的解析，我把视觉小说的基本单元划分为了**幕**和**命令**。

星白的剧本文件分为了一千多幕，并且每一幕包含了若干个命令。幕的概念是指正常情况下的**一次点击**所执行的命令序列，而命令则以操作某个元素的指令的形式呈现，如`移动背景` `移动角色` `播放背景音乐` 等。

在开发的初始，还没有充分的解析星白的剧本文件的时候，我只抽象出了幕的概念，而一幕中固定执行若干条操作语句，剧本文件只需提供固定参数即可

但是我很快就发现了不对劲，因为每一幕的命令的个数和顺序都并不相同，于是我将命令抽象出一个个的函数，与星白中的指令一一对应，最后使用命令表和一个循环来执行剧本所需要的命令

在引擎的开发阶段，我实现了星夜的剧本解析器，并且发现命令可以进行进一步抽象——其实不用关心图片究竟是背景还是角色，也不用关心音频是 bgm 还是语音，这样，就得到了几个通用的操作命令，而在用户侧，相关的具体命令由剧本的**宏**来映射实现

## 快进

快进也是视觉小说开发需要实现的功能，同时我也认为，对于存档的恢复可以等同于快进到存档的幕。由于[前文](暂停)在解决暂停问题时封装 Promise 思路的实现，我想到可以通过立即执行带有延时的代码的方式来实现快进。

起初，我通过控制 setTimeout 的暂停和执行时机来实现越过延时，但是这并不能适用于全部场景：第三方库并不使用我自定义的 setTimeout 实现。

于是，我单独提取出用于添加暂停,恢复和立即执行的回调函数的函数，而具体的实现方式则由各个命令单独处理。这样快进功能，连带着读档功能就实现完毕了。现在跳转到剧本的任何位置都不成问题——只需要像正常运行游戏一样执行剧本中的命令，然后将带有延时的部分立即执行，一切看起来都很好。

然而，问题并未得到完全的解决，星夜架设在 Web 平台，而浏览器并没有这么聪明，它不知道快进时不需要加载游戏资源。于是，快进造成了大量的网络请求，网络带宽的占用和后续正常进行游戏时的卡顿（这时候浏览器还在加载先前那些用不到的资源）。这是一个令人沮丧的问题，我不得不想办法去除游戏快进时命令中的网络请求副作用。

## 幕循环

在视觉小说游戏的运行阶段，需要根据不同的运行状态对用户的点击作不同的响应。在一幕还未执行完毕时的第二次点击会将一幕快进到它的结束，如果在此期间用户点击自动模式按钮则不会有额外的动作产生，如果上一幕已经执行完毕，用户对屏幕或自动模式按钮的点击则会推动游戏开始下一幕。

同一幕的一些命令组合之间存在先后顺序，既然在前文中已经选择了 Promise 控制命令的延时执行，很自然的就能写出一个运行一幕的函数

```ts
async function next(index) {
  for (const data of book[index]) {
    await commands[i.sign](data);
  }
}
```

但是，这只是描述了一幕中的命令之间的时序关系，而没有定义在此期间与它无关的用户点击如何处理

要在函数的执行前后使用可变量去修改状态吗？在大量的编程实践中，我反复遇到类似于上面的场景：程序的下一步操作依赖于多次外部输入，以及当前的执行情况。通过回调函数接收外部输入的方式并没有办法自然的插入程序的执行逻辑中，参考目前其他领域的解决方案，我编写了一个实现了事件订阅/发布模式的模块，和一个产生单次订阅 Promise 的函数，这样以来，就不再需要通过可变状态来反应程序执行情况的变化了，外部输入可以自然的融入程序逻辑。

比如一个在一幕未执行结束时不再接收用户点击的逻辑可以这样表达：

```ts
const rec = async (index) => {
  await onClick();
  await next();
  rec(index + 1);
};
```

继续细化 rec 函数，便构成了运行整个剧本的幕循环

## 游戏状态

在开发视觉小说的过程中，很容易就能注意到视觉小说有几种不同的运行状态：`普通`、`自动`、`快进`。

而基于[前文](快进)提到的读档过程中产生不必要的网络开销的问题，我把`初始化`状态也加入到了其中。虽然初始化状态或许算不上真正的游戏状态，但它确实不与其他三种状态一同出现。

## 初始化

有了初始化作为单独的状态，接下来要解决的就是网络开销的问题，根据编写命令的实践经验，我发现初始化时要运行的代码与平时执行时的大同小异，不过，与第三方库交互则是额外的麻烦。

对于在 canvas 上绘制的图形库而言，它们有 stage、container、bitmap 这样的多层父子级关系，还有 x，y 这样的状态参数，而初始化过程要保留这些数据，同时避免图形库去加载资源。

星夜引擎最初选择的`create.js`似乎有些过时，不过在这个问题上还有的商量：通过一系列奇奇怪怪的非正常方式，总归是实现了需求。

而似乎是常用技术选择的`pixi.js `似乎完全没有考虑到这种场景，加载资源完全不由用户控制，完全没办法实现这个效果。

最终我发现反而是基于 dom 的实现最自然，这个方案也成为了目前的选择。

作为音频库的`howler.js`就要省心的多了，它有专门的方式用来声明懒加载，在初始化之后主动加载即可。

这里涉及到了一个之前没有实现过的内容，“在初始化之后”，这个时机并不在目前命令的执行阶段之内，为了实现这个需求，游戏周期中的生命周期回调也就需要添加到引擎中了

## 生命周期

对于生命周期的定义并没有什么特别的问题出现，随着各个需求的出现，对应用于解决需求的生命周期也被添加进引擎。为了实现命令的初始化，在初始化前执行和在初始化后执行的生命周期被添加进去；注意到一些变量、效果只在一幕内生效，在幕开始和结束时执行的生命周期被添加进去；在游戏过程中，前往设置页面，返回到主界面，再回到游戏页面，也都有对应的不同行为，需要添加对应的生命周期。

值得一提的是在命令对生命周期回调的注册上，在生命周期还比较少时，我采用的是把单个命令和它的生命周期回调放入到同一个对象中统一导出，然后再在注册命令时同时注册回调这样的方式：

```ts
const 命令 = { apply: 命令函数, 生命周期: 命令生命周期函数 };
```

后来，我把生命周期的导入导出以及注册都单独拆分开来，但是缺少了`命令.生命周期`这样的命名区分，每个生命周期函数都需要单独命名。

最终，我发现基于事件订阅与发布的方式最为方便：

```ts
生命周期.订阅(命令生命周期函数);
```

这种方式不必须对函数命名，而且还有额外的好处：如果你不需要这个命令，就不会引入对应的命令文件，也就不会去注册命令附带的回调函数，反之亦然

## 命令与舞台

“舞台”，指视觉小说在游戏过程中显示的内容集合，这些内容有可能由 dom 或 canvas 实现。

在`solid.js`这样的响应式 UI 实现下，要让命令操作舞台元素是很方便的，只需要让命令和命令对应的元素与同一个响应式变量建立联系即可，对于响应式变量定义的位置并没有任何的要求。

由于舞台元素和幕循环运行在同一个游戏实例下，通过函数式的方式定义一个变量集合并向下传递是可行的。

目前的响应式变量定义在命令文件中，对应的舞台元素采用导入的方式使用这个变量。

这样的方案具有[额外的副作用](销毁)，但是它具有变量集合不具备的优点： 1.变量集合必须预先确定它具有的元素和类型，如果添加新的命令，无法直接在命令文件内部为变量集合新增元素，需要修改变量集合的类型定义 2.将所有响应式变量放在一个集合中，不同的命令与元素之间的关系不明确，无法清晰的看到数据的流向

## 命令作用域

在实现命令的过程中，我发现有些命令产生的效果只在它所在的幕内生效，比如`对话框文本`、`角色语音`，这些命令在初始化时可以直接忽略，在幕切换时则需要通过幕开始的生命周期回调去清除它们产生的效果。

其他的命令则产生持续性的效果，直到另外一个命令主动移除这些效果，比如`播放背景音乐`和`停止背景音乐`，这些命令在初始化时需要维护它们的数据，如果在正常运行阶段命令会产生网络请求等额外开销，则需要在初始化阶段单独进行处理来避免。

对于全部命令来说，在重新开始新的游戏的时候都需要将变量重置到初始状态，而对于幕作用域的命令，也存在使用响应式变量来产生舞台效果的实现。

使用生命周期回调只为了重置变量的情况非常常见，所以我单独提取了一个辅助函数，以便避免重复书写相同的代码，并更清晰的表达语义

## 销毁

通过[快进]()配合[初始化]()，似乎游戏的运行架构已经非常完整，而对游戏实例的销毁只需要对所有命令调用它们的暂停函数，这样就好了。

直到我发现有些命令并没有成功暂停，它们产生的影响甚至到达了新的游戏实例，究竟怎么回事呢？经过反复测试，以下是对这个问题的完整结论。

我通过[幕循环]()中介绍过的事件发布/订阅模式传递销毁事件，在销毁事件的回调中对每个命令暂停，而命令的执行链条则通过 Promise 控制。预期上，暂停了命令的执行，
自然，表示命令执行完毕的 Promise 也会停止在 Padding 状态，然而，直到新的游戏实例渲染，命令依次执行完毕之后，销毁事件才最终到达。

wait([此命令未被取消,因为销毁事件还没到达])[快速读档,Game 组件销毁再创建].then([旧实例的命令被释放到了新实例])

[具有副作用的变量传递](命令与舞台)促成了问题的发现，因为响应式变量在不同游戏实例之间共享，旧游戏实例的命令泄露之后直接操作了新实例的舞台元素，在对话文本上明显的造成了文本错乱。

## 命令、阻塞、时间控制

为了解决[销毁]()的问题，需要对命令执行逻辑进行重新设计，要如何做呢？

已有的逻辑表示出 Promise 的作用是标识一个耗时命令块的执行结束，而在快进时，我们加速命令的执行来间接的解决 Promise，有时候这种方式并不起效，在我用过的多个缓动库中，如果直接将缓动效果的时间设置到结束，标识缓动效果完成的 Promise 就不会被解决，而游戏实例销毁时暴露出的异步执行顺序问题更是需要我们对异步链条中的每一个 Promise 加以控制。

既然我们只需要 Promise 反映命令块的执行情况，而不需要 Promise 的返回结果，那么与其间接的推动异步链条向下执行，不如在需要忽略它们的时候明确的忽略。

生成器函数使简洁的表达这个逻辑成为可能，它返回一个生成器，其中每次调用 next()都会执行一段代码，遇到 yield 则返回 yield 右边的值，然后挂起。

只需要让 yield 返回 Promise，接下来如何处理 Promise 就可以由我们自己控制了，在普通的运行状态下，我们可以去等待 Promise 完成，在快进的状态下，我们就可以忽略 Promise 直接调用 next()，这个时候，我们也从由浏览器调度的异步程序中解脱出来，因为执行已经是同步的了。

由命令所需的执行时间，我把命令分类为了三种：无阻塞的命令，这种命令并没有有意义的执行时间，比如`对话框人物名称`

动态命令，这种命令具有一定的执行时间，由引擎根据目前的执行模式调度，比如`图片缓动`

阻塞的命令，这种命令需要等待用户输入，仍然采用普通异步函数的形式书写，会阻塞所在的命令执行链条，比如`选择`

这种分类和[命令作用域]()中根据命令效果作用范围的分类是两个命令的重要特征，而不同种类的命令需要不同的调度逻辑也推动着命令不断细分

## 用户点击与自动推动

对于视觉小说游戏而言，同一幕存在两个事实上的结束：允许用户点击推动游戏进入下一幕，自动模式自动推动游戏进入下一幕。为了语言简洁，暂且称它们为普通结束和自动结束。

如果一幕没有普通结束，用户点击则不会推动游戏进入到下一幕，而是将本幕快进到普通结束，普通结束的标志一般包括文字效果，图像效果的结束。

自动结束则用于自动模式，一幕自动结束之后，自动模式便准备将游戏自动推动到下一幕，自动结束一般比普通模式要长，因为它包括对角色语音的结束，在角色语音结束之前，尽管用户点击已经可以推动游戏进入下一幕，但是自动推动并没有开始起作用。

## 存档,读档,游戏状态

根据视觉小说游戏程序读取存档采取的方式的不同，我将它们分成了三个种类:正读式，存储式，倒读式

存储式是一种有状态的存档方式，需要以某种方式为每个命令维护状态表，在存档时存储这个状态表，在读档时根据状态表恢复命令在舞台上的状态<br/>
正读式不维护状态，而是通过剧本提供的信息，从第零幕开始，**无副作用**的运行命令，直到运行到存档的目标幕<br/>
倒读式从存档的目标幕开始向第零幕读取，从剧本中寻找命令所需的信息并恢复它

这三种模式的优缺点如下：

存储式需要分别编写 操作实际舞台，维护虚拟状态，恢复状态到舞台 三类代码<br/>
状态表不能依赖实际舞台信息，因为在命令运行过程中舞台状态并不是最终状态<br/>
状态是这种模式的一个大麻烦，存储状态也有一些空间上的开销，不过理论上读档的性能应该是最好的<br/>
由于需要事先存储状态，存储式无法实现实时预览

正读式只需要编写操作实际舞台的代码，但是依赖能够消除网络请求副作用的特殊方法<br/>
如果命令的实现方式没有这种方法，则需要回退到类似存储式维护状态表的方式<br/>
正读式不需要存储状态，但是有一些从头读取剧本计算状态的开销

倒读式对于有限状态的命令，只需要从后往前读取到第一条设置该状态的命令信息就可以停止读取，这样就比正读式的性能要好一些<br/>
但这种模式并不适合无限状态的命令，因为这种命令并不能确定所需的信息范围，比如`图片`命令<br/>

星夜引擎具有正读式和倒读式的开发经验，倒读式的局限性和代码成本最终证明这种模式不适合使用<br/>
同类项目[WebGal](https://www.openwebgal.com/zh-cn/)目前使用存储式，而将正读式（被他们称为状态演算）作为下一代引擎的开发目标

实践证明，正读式是最适合视觉小说引擎的存档方式

但是存档并不能完全避免存储状态，包括用户已经选择的选项，存档的预览文本这些状态仍然需要被记录<br/>
其中来自外部用户输入的数据在恢复存档时需要被使用，而用于存档预览的数据则没有更多用处
