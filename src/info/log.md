## 前言
本项目始于21年的那个盛夏，基于[星空列车与白的旅行]()项目制作<br/><br/>
迄今为止，星夜已经经历了两个UI框架，三次UI逻辑调整和四次核心逻辑的重构，由于开发者的个人原因，此项目的开发进程或许在很长一段时间内都无法进入实用，在此，编写一个日志，记录我两年半以来对视觉小说引擎开发的经历和经验

## 一.缩放
在从头开发一款视觉小说游戏时，遇到的第一件事就是如何适配不同的屏幕大小，事实上，视觉小说的布局是**绝对**的（就像其他任何的游戏一样？），它们不需要随着屏幕大小的变化来改变彼此之间的大小和距离比例，然而，在Web平台上实现这一点却需要废一番功夫<br/>
一开始，我采用了Web开发中常用的UI自适应方案（尽管这其实并不适合于视觉小说的开发，但是我当时并不能意识到这一点），使用rem和em来确定相对单位，利用复杂的css样式来实现相对的比例保持，然而这在略复杂的html嵌套中就会造成巨大工作量以及难以处理的问题，并且仍旧会造成UI的偏移，为了实现`星空列车与白的旅行`的UI布局，我按了一个礼拜的计算器来把绝对数值转换为相对比例，当时我就在设想一个使用绝对坐标和自动缩放来实现屏幕自适应的方式了<br/>
在第二版方案里，我发现了`scale`这个css属性，它可以对下层元素进行缩放，完美的符合了我的需求。通过参考和摸索，我实现了通过屏幕尺寸来计算scale属性的数值，并把这个自适应功能的实现封装成为组件，这样，UI的编写者只需要通过一个固定的画布大小来编写UI，并书写同样使用固定的**px**单位的css，而无需关心UI自适应的问题<br/>
视觉小说的布局有两种可能的方式，`铺满屏幕`和`保持比例`：采用铺满屏幕的方式会使画面变形来填满屏幕，而保持画布比例的方式则会在屏幕的上下或左右留下空白边缘。星夜同时支持这两者，留给用户自由选择<br/>
## 二.睡眠
解决了开发视觉小说UI出现的问题，接下来就要进行游戏逻辑的开发了，而首先让我头疼的就是游戏要如何暂停，这在其他语言中是一个感觉比较好解决的问题，只需使用sleep就可以停止线程的运行，但是在js中却是一个麻烦的问题，因为js只有单线程，并且不能sleep<br/>
我在网上查询了一些资料，使用while(true)实现的sleep简直异想天开，最终卡死了我的浏览器，在无计可施的时候我甚至尝试将函数toString再切分来实现我的目的，最终在一番尝试之后，我发现了封装Promise的思路，并且实现了await sleep(time) ，这同时部分解决了`快进`的问题，时间控制的实现构成了星夜的核心，它支持任意的跳转和精细的暂停，也是星夜`正读式`思路的结晶<br/>
## 三.幕与命令
开发视觉小说游戏逻辑要遇到的另一个问题就是剧本结构的设计，得益于对`星空列车与白的旅行`原作的解析，我把视觉小说的基本单元划分为了**幕**和**命令**，在之后获取到了开发经验之后，我将命令进行了进一步的抽象<br/>
星白的剧本文件分为了一千多幕，并且每一幕包含了若干个命令。幕的概念是指正常情况下，不包括立即快进之类情况的**一次点击**，而命令在星白里则以指令的形式呈现，如`移动背景` `移动角色` `播放bgm` 等。<br/>
在开发的初始，还没有充分的解析星白的剧本文件的时候，我只抽象出了幕的概念，而一幕中固定执行若干条操作语句，剧本文件只需提供固定参数即可<br/>
但是我很快就发现了不对劲，因为每一幕的命令的个数和顺序都并不相同，于是我将命令抽象出一个个的函数，与星白中的指令一一对应，最后在游戏逻辑中使用map和一个循环来执行剧本所需要的命令<br/>
在引擎的开发阶段，我实现了星夜的剧本解析器，并且发现命令可以进行进一步抽象——其实不用关心图片究竟是背景还是角色，也不用关心音频是bgm还是语音，这样，就得到了几个通用的操作命令，而在用户侧，相关的具体命令由剧本的**宏**来映射实现
## 四.快进与双击
快进也是视觉小说开发需要实现的功能，而在一幕还未执行完毕时的第二次点击也会将一幕快进到它的结束。由于[前文](#二-睡眠)在解决睡眠问题时封装Promise思路的实现，在此思路之下，我通过添加额外的代码包装了setTimeout，实现了将带有延迟的代码立即执行的功能，于是，不只是快进，现在前往剧本任何位置的跳转都不成问题了——只需要像正常运行游戏一样执行剧本中的命令，然后将带有延时的部分立即执行。这样一来，存档加载和BackLog恢复的功能也顺便实现了，一切看起来都很好。<br/>
然而，问题并未得到完全的解决，星夜架设在Web平台，而浏览器并没有这么聪明，它不知道快进的视图会一闪而过，不需要加载资源！于是，快进造成了大量的网络请求，流量的消耗和后续正常进行游戏时的卡顿（这时候浏览器还在加载先前那些游戏快进时候的资源）。这是一个令人沮丧的问题，我不得不想办法去除游戏快进时命令中的网络请求副作用。<br/>
未完待续...
## 四.UI自定义
在计划第三版UI方案时，我已经发现了在视觉小说UI创作过程中的一些特点，除了UI的布局是绝对的之外，我们的游戏通常在几个按钮之间保持相同的间距，而且每个UI元素都基本没有太复杂的绑定事件，而是一个或几个元素对应一个特定的功能<br/>
在按钮间保持相同的比例也需要计算对应的css，这仍然离不开那个让人头大的计算器，而事件绑定的简单也让我看到了UI自定义的可行性，我决定实现UI自定义这个很实用的功能，也方便我进行下一步其他项目的UI开发<br/>
我参照C4D的功能把UI分为了生成器，效果器和元素这几部分，（具体思路待补充）<br/>
为了更自然的实现上述的效果，我希望像普通的变量一样操作UI，主流的Vue，React框架的能力不足以支持这部分开发，起初，我尝试使用json格式来实现UI的自定义，并计划在之后开发自定义的UI编辑器来生成json（实际上我是通过设想UI编辑器的功能来计划json格式语法的），在缺少可用框架的思路下我不得不分离对UI元素和属性的运算和对UI的渲染这两部分，这让我搓了好一段时间的小型解析器来拆分json中自定义的语法字符串，使用eval之类的奇怪手段来实现功能，最终通过定义一个递归循环来渲染UI，然而解析器对于个人开发者而言实在是一个麻烦的工程，而json格式的UI自定义也还是太过繁琐以及实现思路上也还有一些问题，第一版UI自定义最终以失败告终<br/>
因为解析器的问题，我最终还是选择了退后一步，这时我已经换用了 Solid 框架，它jsx的写法和符合思维的模式可以解决Vue和React难以解决的问题，我使用jsx层层封装组件，另外选择了getset一体的`micro-reactive`来实现响应式，最终实现了UI的基本封装，因为在我的`元素/生成器`思路中，属性作为元素自身的参数也无需写到外部css里，这会让生成器无法进行运算并且元素信息不清晰，所以我采用了内联样式的写法，而`伪类`不能内联的问题我最终采用了style-jsx的方式解决<br/>
虽然UI自定义最终得到了基本的实现，但遗憾的是，处理jsx需要一整个编译器工具链，虽然Solid有一些web component的解决方案，但语法转换的成本代价也是难以承受的。而jsx的语法对于视觉小说这个任务而言也是有很多不必要的冗余，使得嵌套层级过深，之后要开发UI编辑器与jsx对接大概也是比较困难的问题。总之，在方便普通用户这件事情上，进展仍旧不多<br/>
未完待续...