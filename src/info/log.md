## 前言

本项目始于 2021 年夏，基于[星空列车与白的旅行](https://cusky.tk/webgal/hoshizora/)移植项目。

迄今为止，星夜已经经历了数次 UI 逻辑和核心逻辑的重构，由于工作量和时间的不平衡，此项目的目标或许在很长一段时间内都无法达到，在此，编写一个日志，记录这些时间以来对视觉小说引擎开发的经历和经验。

日志已经进行了一些重写和提炼，如果有疑问，可以尝试在文档的历史提交中查看旧日志。

## 这不是一个响应式网页！

对于视觉小说常见的 UI 布局而言，每一个按钮的大小、位置都是固定的，只需要根据屏幕大小保持比例，使用 scale 属性就能良好的实现这个效果。

不要使用`%` `em` `rem`的前端响应式方法构建界面，嵌套百分比会使得 CSS 难以阅读，浏览器字体不得小于 12px 的限制则最终使这个方法不能实现目的。

## 概念的基石：幕与命令

视觉小说的基本单元是幕，而操作的基本单元是命令，一幕包含若干条命令，在幕结束之后，需要等待用户点击进入下一幕，而在幕结束之前再次点击则会立即结束本幕。

自动模式相当于在幕结束后代替用户进行点击操作，但是如果幕中的其他命令都已执行完毕，语音仍在播放，自动模式会等待语音播放完毕后进入下一幕，用户主动点击则会立即进入下一幕。

快进模式相当于在自动模式的基础上再代替用户点击一次，这样每一幕都会立即结束，呈现出来的就是每一幕的最终状态。

## 道路的分岔口：存档

存档是视觉小说系统的关键功能之一，要如何实现它呢？

或许可以想到快进和读档之间存在某种一致性，快进到存档位置相当于进行了读档，这种方式称为状态演算。

根据存档的字面含义，则可以想到存储当前的游戏状态，通过恢复它完成读档，这种方式称为状态存储。

状态演算从剧本第 0 幕开始，在读档过程中，舞台不应该呈现效果，状态演算需要通过技巧消除这些副作用。

外部输入，如用户选择的选项，不属于剧本的一部分，使用状态演算的方式也需要存储它们，并在读档过程中填入。

状态演算的缺点在于从第 0 幕开始计算状态，剧本越长读档速度就越慢，在千和万的数量级还可以接受，更长的剧本则需要通过拆分场景的方式解决。

状态存储需要维护一个状态表，这不能够通过简单的获取当前运行状态来实现。

在读档时需要从存档点所在幕的开头开始，所以需要某种方法获得幕开始和结束时的状态，根据状态表恢复状态也需要编写额外的代码。

状态存储的缺点在于状态表与实际舞台的运行时数据结构是分离的，每新增一个舞台元素，都需要对应的实现它在状态表中的存储和恢复操作。

## 从简单到复杂：组合

## 实现细节：幕与命令

在视觉小说游戏的运行阶段，需要根据不同的运行状态对用户的点击作不同的响应。在幕结束之前的点击会立即结束本幕，在幕结束之前切换到自动模式不会发生任何事情，如果幕已经结束，用户点击或切换到自动模式则会推动游戏开始下一幕。

要在函数的执行前后使用可变量去修改状态吗？在大量的编程实践中，我反复遇到类似于上面的场景：程序的下一步操作依赖于多次外部输入，以及当前的执行情况。通过回调函数接收外部输入的方式并没有办法自然的插入程序的执行逻辑中，参考目前其他领域的解决方案，我编写了一个实现了事件订阅/发布模式的模块，和一个产生单次订阅 Promise 的函数，这样以来，就不再需要通过可变状态来反应程序执行情况的变化了，外部输入可以自然的融入程序逻辑。

比如一个在一幕未执行结束时不再接收用户点击的逻辑可以这样表达：

```ts
const rec = async (index) => {
  await onClick();
  await next();
  rec(index + 1);
};
```

继续细化 rec 函数，便构成了运行整个剧本的幕循环

## 实现细节：生命周期

对于生命周期的定义并没有什么特别的问题出现，随着各个需求的出现，对应解决需求的生命周期也被添加进来。为了实现命令的初始化，在初始化前执行和在初始化后执行的生命周期被添加进去；注意到一些变量、效果只在一幕内生效，在幕开始和结束时执行的生命周期被添加进去；在游戏过程中，前往设置页面，返回到主界面，再回到游戏页面，也都有对应的不同行为，需要添加对应的生命周期。

值得一提的是在命令对生命周期回调的注册上，在生命周期还比较少时，我采用的是把单个命令和它的生命周期回调放入到同一个对象中统一导出，然后再在注册命令时同时注册回调这样的方式：

```ts
const 命令 = { apply: 命令函数, 生命周期: 命令生命周期函数 };
```

后来，我把生命周期的导入导出以及注册都单独拆分开来，但是缺少了`命令.生命周期`这样的命名区分，每个生命周期函数都需要单独命名。

最终，我发现基于事件订阅与发布的方式最为方便：

```ts
生命周期.订阅(命令生命周期函数);
```

这种方式不必须对函数命名，而且还有额外的好处：如果你不需要这个命令，就不会引入对应的命令文件，也就不会去注册命令附带的回调函数，反之亦然
